using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;

namespace Devlooped.Extensions.DependencyInjection.Attributed;

/// <summary>
/// Discovers annotated services during compilation and generates the partial method 
/// implementations for <c>AddServices</c> to invoke.
/// </summary>
[Generator(LanguageNames.CSharp)]
public class IncrementalGenerator : IIncrementalGenerator
{
    static readonly SymbolDisplayFormat fullNameFormat = new SymbolDisplayFormat(
        typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
        genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
        miscellaneousOptions: SymbolDisplayMiscellaneousOptions.ExpandNullable);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var types = context.CompilationProvider.SelectMany((x, c) =>
        {
            var visitor = new TypesVisitor(s => x.IsSymbolAccessibleWithin(s, x.Assembly), c);
            x.GlobalNamespace.Accept(visitor);
            return visitor.TypeSymbols;
        });

        // NOTE: we recognize the attribute by name, not precise type. This makes the generator 
        // more flexible and avoids requiring any sort of run-time dependency.
        var services = types
            .Where(x => x.GetAttributes().Any(a =>
                a.AttributeClass?.Name == "ServiceAttribute" &&
                a.ConstructorArguments.Length == 1 &&
                a.ConstructorArguments[0].Value is int))
            .Select((x, _) => new
            {
                Type = x,
                Lifetime = (int)x.GetAttributes().First(a => a.AttributeClass?.Name == "ServiceAttribute").ConstructorArguments[0].Value!
            });

        // Only requisite is that we define Scoped = 0, Singleton = 1 and Transient = 2.
        // This matches https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.servicelifetime?view=dotnet-plat-ext-6.0#fields
        var singleton = services.Where(x => x.Lifetime == 0).Select((x, _) => x.Type).Collect().Combine(context.AnalyzerConfigOptionsProvider);
        var scoped = services.Where(x => x.Lifetime == 1).Select((x, _) => x.Type).Collect().Combine(context.AnalyzerConfigOptionsProvider);
        var transient = services.Where(x => x.Lifetime == 2).Select((x, _) => x.Type).Collect().Combine(context.AnalyzerConfigOptionsProvider);

        context.RegisterSourceOutput(scoped, (ctx, data) => AddPartial("AddScoped", ctx, data));
        context.RegisterSourceOutput(singleton, (ctx, data) => AddPartial("AddSingleton", ctx, data));
        context.RegisterSourceOutput(transient, (ctx, data) => AddPartial("AddTransient", ctx, data));
    }

    void AddPartial(string methodName, SourceProductionContext ctx, (ImmutableArray<INamedTypeSymbol> Types, AnalyzerConfigOptionsProvider Options) data)
    {
        var builder = new StringBuilder();

        var rootNs = data.Options.GlobalOptions.TryGetValue("build_property.AddServicesNamespace", out var value) && !string.IsNullOrEmpty(value)
            ? value
            : "Microsoft.Extensions.DependencyInjection";

        var className = data.Options.GlobalOptions.TryGetValue("build_property.AddServicesClassName", out value) && !string.IsNullOrEmpty(value) ?
            value : "AddServicesExtension";

        builder.AppendLine(
          $$"""
            // <auto-generated />
            using Microsoft.Extensions.DependencyInjection;
            
            namespace {{rootNs}}
            {
                static partial class {{className}}
                {
                    static partial void {{methodName}}Services(IServiceCollection services)
                    {
            """);

        AddServices(data.Types, methodName, builder);
        builder.AppendLine(
        """
                    }
                }
            }
            """);

        ctx.AddSource(methodName + ".g", builder.ToString().Replace("\r\n", "\n").Replace("\n", Environment.NewLine));
    }

    void AddServices(ImmutableArray<INamedTypeSymbol> types, string methodName, StringBuilder output)
    {
        foreach (var type in types)
        {
            var impl = type.ToDisplayString(fullNameFormat);
            output.AppendLine($"            services.{methodName}<global::{impl}>();");
            foreach (var iface in type.AllInterfaces)
            {
                output.AppendLine($"            services.{methodName}<global::{iface.ToDisplayString(fullNameFormat)}>(s => s.GetRequiredService<global::{impl}>());");
            }
        }
    }

    class TypesVisitor : SymbolVisitor
    {
        Func<ISymbol, bool> isAccessible;
        CancellationToken cancellation;
        HashSet<INamedTypeSymbol> types = new(SymbolEqualityComparer.Default);

        public TypesVisitor(Func<ISymbol, bool> isAccessible, CancellationToken cancellation)
        {
            this.isAccessible = isAccessible;
            this.cancellation = cancellation;
        }

        public HashSet<INamedTypeSymbol> TypeSymbols => types;

        public override void VisitAssembly(IAssemblySymbol symbol)
        {
            cancellation.ThrowIfCancellationRequested();
            symbol.GlobalNamespace.Accept(this);
        }

        public override void VisitNamespace(INamespaceSymbol symbol)
        {
            foreach (var namespaceOrType in symbol.GetMembers())
            {
                cancellation.ThrowIfCancellationRequested();
                namespaceOrType.Accept(this);
            }
        }

        public override void VisitNamedType(INamedTypeSymbol type)
        {
            cancellation.ThrowIfCancellationRequested();

            if (!isAccessible(type) || !types.Add(type))
                return;

            var nestedTypes = type.GetTypeMembers();
            if (nestedTypes.IsDefaultOrEmpty)
                return;

            foreach (var nestedType in nestedTypes)
            {
                cancellation.ThrowIfCancellationRequested();
                nestedType.Accept(this);
            }
        }
    }
}
